import { GET, POST } from "@/app/api/forms/route";
import { prisma } from "@/lib/database";
import { Form } from "@prisma/client";

const TEST_FORM_DATA = { title: "form title", fields: [] };

type FormsListResponse = {
  forms: Form[];
  total: number;
  hasMore: boolean;
};

type ApiResponse<T> = {
  success: boolean;
  data: T;
};

type ErrorResponse = {
  success: boolean;
  error: string;
};

describe("Forms API Route", () => {
  beforeEach(async () => {
    await prisma.form.deleteMany({});
    await prisma.submission.deleteMany({});
  });

  afterAll(async () => {
    prisma.$disconnect();
  });

  describe("GET /api/forms", () => {
    test("return forms data with default pagination (200 status)", async () => {
      const request = new Request("http://localhost:3000/api/forms");
      const response = await GET(request);
      const { success, data }: ApiResponse<FormsListResponse> =
        await response.json();

      expect(response.status).toBe(200);
      expect(success).toBe(true);
      expect(data.forms).toHaveLength(0);
      expect(data.total).toBe(0);
      expect(data.hasMore).toBe(false);
    });

    test("return forms data with limit and offset (200 status)", async () => {
      await prisma.form.createMany({
        data: [TEST_FORM_DATA, TEST_FORM_DATA, TEST_FORM_DATA],
      });

      const request = new Request(
        "http://localhost:3000/api/forms?limit=1&offset=1"
      );
      const response = await GET(request);
      const { success, data }: ApiResponse<FormsListResponse> =
        await response.json();

      expect(response.status).toBe(200);
      expect(success).toBe(true);
      expect(data.forms).toHaveLength(1);
      expect(data.total).toBe(3);
      expect(data.hasMore).toBe(true);
    });

    // this test should focus on internal server error at API route level, not database failure
    // consider bubbling up errors from db-operations to API route and rewrite tests
    test("handle database error (500 status)", async () => {
      jest.spyOn(console, "error").mockImplementationOnce(() => {});
      jest.spyOn(prisma.form, "findMany").mockRejectedValueOnce(new Error());

      const request = new Request("http://localhost:3000/api/forms");

      const response = await GET(request);
      const { success, error }: ErrorResponse = await response.json();

      expect(response.status).toBe(500);
      expect(success).toBe(false);
      expect(error).toBe("Failed to fetch forms");
    });
  });

  describe("POST /api/forms", () => {
    test("create new form successfully (201 status)", async () => {
      const request = new Request("http://localhost:3000/api/forms", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(TEST_FORM_DATA),
      });

      const response = await POST(request);
      const { success, data }: ApiResponse<Form> = await response.json();

      expect(response.status).toBe(201);
      expect(success).toBe(true);
      expect(data).toHaveProperty("id");
      expect(data.title).toBe(TEST_FORM_DATA.title);
      expect(data.fields).toEqual(TEST_FORM_DATA.fields);
    });

    test("return error when required fields are missing (400 status)", async () => {
      const request = new Request("http://localhost:3000/api/forms", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({}),
      });

      const response = await POST(request);
      const { success, error }: ErrorResponse = await response.json();

      expect(response.status).toBe(400);
      expect(success).toBe(false);
      expect(error).toBe("Title and fields are required");
    });

    test("handle malformed JSON (500 status)", async () => {
      const consoleErrorSpy = jest
        .spyOn(console, "error")
        .mockImplementation(() => {});

      const request = new Request("http://localhost:3000/api/forms", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: "{ invalid json",
      });

      const response = await POST(request);
      const { success, error }: ErrorResponse = await response.json();

      expect(response.status).toBe(500);
      expect(success).toBe(false);
      expect(error).toBe("Internal server error");

      consoleErrorSpy.mockRestore();
    });
  });
});
